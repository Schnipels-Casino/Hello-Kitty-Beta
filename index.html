<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Match-3 ‚Äî Endless</title>
  <style>
    :root{ --gap:8px; --radius:16px; --ink:#1a1333; --muted:#7b6a84; --accent:#ef5da8; --accent2:#60a5fa; }
    *{ box-sizing:border-box }
    body{
      margin:0; color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Inter, Arial, sans-serif;
      display:flex; justify-content:center; min-height:100vh; padding:12px;
      background:#ffd7f1;
      background-image:
        radial-gradient(1200px 900px at 20% 25%, rgba(255,170,230,.45), transparent 60%),
        radial-gradient(1000px 1200px at 78% 30%, rgba(170,150,255,.35), transparent 60%),
        radial-gradient(1400px 1000px at 40% 85%, rgba(250,210,255,.32), transparent 60%);
      position:relative; overflow-x:hidden;
    }
    #starfield{ position:fixed; inset:0; z-index:-1; pointer-events:none; display:block; }
    .wrap{ position:relative; z-index:1; display:flex; flex-direction:column; gap:10px; align-items:center; max-width:900px; width:100% }
    header{
      background:rgba(255,255,255,.85); backdrop-filter: blur(6px);
      border:1px solid rgba(0,0,0,.06); border-radius:var(--radius);
      box-shadow: 0 10px 24px rgba(0,0,0,.12); padding:10px 12px; width:100%;
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .stat{ font-weight:800 } .sub{ font-size:.9rem; color:var(--muted) }
    .btn{ appearance:none; border:0; background:linear-gradient(135deg,var(--accent),var(--accent2)); color:#fff; font-weight:700; padding:8px 12px; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.12); cursor:pointer; }
    .btn:active{ transform: translateY(1px); }
    .btn[aria-pressed="false"]{ filter:grayscale(1) brightness(0.9); }

    .tools{
      display:flex; gap:10px; align-items:center; justify-content:center;
      flex: 1 1 auto; flex-wrap: nowrap; max-width: 100%; overflow: visible;
    }
    .btn-tool{
      width:40px; height:40px; border-radius:999px; border:0; cursor:pointer;
      display:grid; place-items:center; color:#fff; position:relative;
      background:linear-gradient(135deg,#ef5da8,#60a5fa);
      box-shadow: 0 8px 20px rgba(0,0,0,.12);
    }
    .btn-tool[aria-pressed="true"]{ outline:3px solid rgba(96,165,250,.5); }
    .btn-tool:disabled{ filter:grayscale(1) brightness(.85); cursor:not-allowed; opacity:.7; }
    .btn-tool .badge{
      position:absolute; top:-6px; right:-6px;
      background:#fff; color:#1a1333; border:2px solid rgba(0,0,0,.06);
      min-width:18px; height:18px; padding:0 4px; border-radius:999px;
      display:none; align-items:center; justify-content:center;
      font-size:12px; font-weight:800; box-shadow:0 6px 12px rgba(0,0,0,.12);
    }
    .btn-tool .badge.show{ display:flex; }
    .btn-tool.unlock-pop{ animation: unlockPop .42s ease-out; }
    @keyframes unlockPop{ 0%{ transform: scale(.85)} 60%{ transform: scale(1.18)} 100%{ transform: scale(1)} }

    .board-wrap{ background:transparent; border-radius:var(--radius); padding:0; display:flex; justify-content:center; width:100%; }
    #board{
      position: relative; width: min(92vw, 520px); aspect-ratio: 1 / 1; border-radius: 20px; overflow: hidden; touch-action: none;
      background: radial-gradient(800px 600px at 25% 25%, rgba(255,200,255,.28), transparent 60%),
                  radial-gradient(900px 700px at 75% 65%, rgba(170,150,255,.24), transparent 60%),
                  radial-gradient(1000px 900px at 50% 50%, rgba(255,240,255,.18), transparent 60%);
      box-shadow: inset 0 0 120px rgba(140,50,200,.18), 0 12px 28px rgba(0,0,0,.12);
    }
    #board::after{ content:""; position:absolute; inset:0; z-index:0; pointer-events:none;
      background-image: radial-gradient(#fff 0 1px, transparent 1.5px); background-size: 80px 80px; opacity:.22; animation: drift 26s linear infinite; }
    @keyframes drift{ from{ transform:translate(0,0)} to{ transform:translate(70px,50px)} }

    .tile{
      position:absolute; z-index:1;
      display:grid; place-items:center;
      border-radius:14px; background-color: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.18);
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      transition: transform .18s ease, opacity .2s ease;
      will-change: transform, opacity;
      user-select:none; backdrop-filter: blur(2px);
      line-height:1;
    }
    .tile.selected{ outline:3px solid var(--accent2); box-shadow: 0 10px 22px rgba(96,165,250,.35); }
    .tile.match{ animation: pop .22s ease-out forwards; }
    @keyframes pop{ 0%{ transform: scale(1); opacity:1 } 50%{ transform: scale(1.2); opacity:.9 } 100%{ transform: scale(0.1); opacity:0 } }

    /* Flash-Badges bei 4er/5er */
    .tile.flash-rocket, .tile.flash-bomb{ position:absolute; }
    .tile.flash-rocket{ animation: flashPulse .5s ease-out 2; }
    .tile.flash-bomb{  animation: flashPulse .5s ease-out 2; }
    .tile.flash-rocket::after,
    .tile.flash-bomb::after{
      position:absolute; top:-6px; right:-6px;
      min-width:18px; height:18px; padding:0 4px; border-radius:999px;
      display:grid; place-items:center; font-size:12px; font-weight:800;
      background:#fff; color:#1a1333; border:2px solid rgba(0,0,0,.06);
      box-shadow:0 6px 12px rgba(0,0,0,.12); pointer-events:none;
      content: "";
    }
    .tile.flash-rocket::after{ content: "üöÄ"; }
    .tile.flash-bomb::after{ content: "üí£"; }

    @keyframes flashPulse{
      0%{ box-shadow: 0 0 0 0 rgba(96,165,250,.0); transform: scale(1); }
      50%{ box-shadow: 0 0 0 8px rgba(96,165,250,.35); transform: scale(1.06); }
      100%{ box-shadow: 0 0 0 0 rgba(96,165,250,.0); transform: scale(1); }
    }

    .tile.rocket-pop{ animation: rocketPop .22s ease-out forwards; }
    @keyframes rocketPop{ 0%{ transform:scale(1)} 80%{ transform:scale(1.2); opacity:.9 } 100%{ transform:scale(0.1); opacity:0 } }
    .tile.bomb-pop{ animation: bombPop .24s ease-out forwards; }
    @keyframes bombPop{ 0%{ transform:scale(1) } 50%{ transform:scale(1.25) rotate(8deg) } 100%{ transform:scale(0.1); opacity:0 } }
    .tile.kitty-pop{ animation: kittyPop .28s ease-out forwards; }
    @keyframes kittyPop{ 0%{ transform:scale(1) } 60%{ transform:scale(1.25) rotate(-6deg)} 100%{ transform:scale(0.1); opacity:0 } }

    footer{ display:flex; justify-content:center; padding:6px 0; }
    .info-panel{
      position: fixed; left:50%; bottom:16px; transform: translateX(-50%);
      background: rgba(255,255,255,.95); backdrop-filter: blur(6px);
      border:1px solid rgba(0,0,0,.06); border-radius: 16px; padding:14px 16px;
      box-shadow: 0 14px 36px rgba(0,0,0,.18);
      width:min(92vw, 560px); z-index:10;
    }
    .info-panel[hidden]{ display:none; }
    .info-panel h3{ margin:0 0 8px 0; font-size:1.05rem }
    .info-panel ul{ margin:8px 0; padding-left:18px }
    .info-actions{ display:flex; justify-content:flex-end; margin-top:8px }
  </style>
</head>
<body>
  <canvas id="starfield"></canvas>
  <div class="wrap">
    <header>
      <div>
        <div class="stat">Punkte: <span id="score">0</span></div>
        <div class="sub">Bestleistung: <span id="best">0</span></div>
      </div>
      <div class="tools" aria-label="Werkzeuge">
        <button class="btn-tool" id="btnJoker" title="Joker: Feld neu mischen (1√ó/Spiel)" aria-pressed="false">
          <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
            <path d="M12 5v-2l-3 3 3 3V7a5 5 0 1 1-5 5H5a7 7 0 1 0 7-7z" fill="currentColor"/>
          </svg>
        </button>
        <button class="btn-tool" id="btnRocket" title="Rakete: Spalte sprengen" aria-pressed="false" disabled>
          <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
            <path d="M3 21l4-1 5-5-3-3-5 5-1 4zM14 3l7 7-7 7-7-7 7-7z" fill="currentColor"/>
            <path d="M14 3l-3 6 4 4 6-3-7-7z" fill="currentColor" opacity=".5"/>
          </svg>
          <span class="badge" id="countRocket">0</span>
        </button>
        <button class="btn-tool" id="btnBomb" title="Bombe: 8 Felder rundum" aria-pressed="false" disabled>
          <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
            <circle cx="10" cy="14" r="6" fill="currentColor"/>
            <path d="M14 6l2-2 3 3-2 2" stroke="currentColor" stroke-width="2" fill="none"/>
            <circle cx="20" cy="4" r="1" fill="currentColor"/>
          </svg>
          <span class="badge" id="countBomb">0</span>
        </button>
        <button class="btn-tool" id="btnKitty" title="Kitty-Power: alle gleichen Figuren l√∂schen (nach 15 Feldern)" aria-pressed="false" disabled>
          <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
            <circle cx="8" cy="12" r="3.2" fill="currentColor"/>
            <circle cx="16" cy="12" r="3.2" fill="currentColor"/>
            <circle cx="12" cy="12" r="2.2" fill="currentColor" opacity=".85"/>
          </svg>
          <span class="badge" id="countKitty">0</span>
        </button>
      </div>
      <div class="hud">
        <button class="btn" id="new">Neu starten</button>
        <button class="btn" id="toggleSound" aria-pressed="true">üîä Sound an</button>
      </div>
    </header>

    <div class="board-wrap">
      <div id="board" aria-label="Spielfeld 8 mal 8"></div>
    </div>

    <footer>
      <button class="btn" id="infoBtn">‚ÑπÔ∏è Info</button>
    </footer>
  </div>

  <div id="infoPanel" class="info-panel" hidden role="dialog" aria-modal="true" aria-labelledby="infoTitle">
    <h3 id="infoTitle">So spielst du</h3>
    <p>Wische (Finger/Maus gedr√ºckt halten) eine Kachel zu einer benachbarten, um 3 oder mehr gleiche zu kombinieren.</p>
    <ul>
      <li><strong>Joker (1√ó/Spiel):</strong> mischt das Feld neu.</li>
      <li><strong>Rakete:</strong> sprengt eine komplette Spalte (bei <strong>4er-Kombos</strong>).</li>
      <li><strong>Bombe:</strong> sprengt <strong>8 Nachbarfelder</strong> (ab <strong>5er-Kombos</strong>).</li>
      <li><strong>Kitty-Power:</strong> l√∂scht alle gleichen Figuren der gew√§hlten Sorte (l√§dt nach je <strong>15 Dreier-Kombos</strong>).</li>
      <li><strong>Sound:</strong> oben im Header ein-/ausschalten.</li>
    </ul>
    <div class="info-actions">
      <button class="btn" id="closeInfo">Schlie√üen</button>
    </div>
  </div>

<script>
'use strict';

/* Emojis (üê≠ ‚Üí üê∑ ersetzt) */
const EMOJIS = ["üê∂","üê±","üê∑","üêπ","üê∞","ü¶ä","üêª","üêº"];

const COLS = 8, ROWS = 8, TYPES = EMOJIS.length;
let board = [];
let score = 0;
let best = +(localStorage.getItem("kitty-best")||0);
let chain = 0;
let busy = false;

let toolMode = 'none';
let jokerUsed = false;
let rocketUnlocked = false, bombUnlocked = false, kittyUnlocked = false;
let rocketCharges = 0, bombCharges = 0, kittyCharges = 0;
let kittyProgress = 0;

const elBoard = document.getElementById("board");
const elScore = document.getElementById("score");
const elBest  = document.getElementById("best");
elBest.textContent = best;

const sleep = (ms)=> new Promise(r => setTimeout(r, ms));

/* Innenrand = L√ºcke f√ºr cleanen Board-Rand */
function stepPx(){
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8;
  const W = elBoard.clientWidth;
  const pad = gap;
  return (W - 2*pad + gap) / COLS;
}
function randType(){ return (Math.random()*TYPES)|0; }

function updateBadges(){
  const r = document.getElementById('countRocket');
  const b = document.getElementById('countBomb');
  const k = document.getElementById('countKitty');
  if (r){ r.textContent = String(rocketCharges||0); r.classList.toggle('show', (rocketCharges||0) > 0); }
  if (b){ b.textContent = String(bombCharges||0);   b.classList.toggle('show', (bombCharges||0) > 0); }
  if (k){ k.textContent = String(kittyCharges||0);  k.classList.toggle('show', (kittyCharges||0) > 0); }
}
function refreshToolsUI(){ updateBadges();
  const rbtn = document.getElementById('btnRocket');
  const bbtn = document.getElementById('btnBomb');
  const kbtn = document.getElementById('btnKitty');
  if (rbtn) rbtn.disabled = rocketCharges <= 0;
  if (bbtn) bbtn.disabled = bombCharges <= 0;
  if (kbtn) kbtn.disabled = kittyCharges <= 0;
}
function setTool(mode){
  if (busy) return;
  if (toolMode === mode) mode = 'none';
  toolMode = mode;
  document.getElementById('btnJoker').setAttribute('aria-pressed', String(mode==='joker'));
  document.getElementById('btnRocket').setAttribute('aria-pressed', String(mode==='rocket'));
  document.getElementById('btnBomb').setAttribute('aria-pressed', String(mode==='bomb'));
  const k = document.getElementById('btnKitty'); if (k) k.setAttribute('aria-pressed', String(mode==='kitty'));
}
document.addEventListener('DOMContentLoaded', ()=>{
  const btnJ = document.getElementById('btnJoker');
  const btnR = document.getElementById('btnRocket');
  const btnB = document.getElementById('btnBomb');
  const btnK = document.getElementById('btnKitty');
  btnJ.addEventListener('click', ()=>{ if (jokerUsed) return; setTool('joker'); });
  btnR.addEventListener('click', ()=> { if (rocketCharges<=0) return; setTool('rocket'); });
  btnB.addEventListener('click', ()=> { if (bombCharges<=0) return; setTool('bomb'); });
  btnK.addEventListener('click', ()=> { if (kittyCharges<=0) return; setTool('kitty'); });

  // Info Panel
  const infoBtn = document.getElementById('infoBtn');
  const panel = document.getElementById('infoPanel');
  const closeInfo = document.getElementById('closeInfo');
  function openInfo(){ panel.hidden = false; }
  function closePanel(){ panel.hidden = true; }
  infoBtn.addEventListener('click', openInfo);
  closeInfo.addEventListener('click', closePanel);
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closePanel(); });
});

function init(){
  jokerUsed = false;
  rocketUnlocked = bombUnlocked = kittyUnlocked = false;
  rocketCharges = bombCharges = kittyCharges = 0;
  kittyProgress = 0;
  const btnJ = document.getElementById('btnJoker'); if (btnJ){ btnJ.disabled=false; btnJ.setAttribute('aria-pressed','false'); }
  const rbtn = document.getElementById('btnRocket'); if (rbtn){ rbtn.disabled = true; rbtn.setAttribute('aria-pressed','false'); }
  const bbtn = document.getElementById('btnBomb'); if (bbtn){ bbtn.disabled = true; bbtn.setAttribute('aria-pressed','false'); }
  const kbtn = document.getElementById('btnKitty'); if (kbtn){ kbtn.disabled = true; kbtn.setAttribute('aria-pressed','false'); }
  refreshToolsUI();
  score = 0; chain = 0; updateScore(0);
  board = Array.from({length: ROWS}, () => Array.from({length: COLS}, randType));
  (async () => { await resolveMatches(true); draw(); })();
}

function draw(){
  elBoard.innerHTML = "";
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8;
  const pad = gap;
  const step = stepPx();
  const tile = step - gap;
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const t = document.createElement("div");
      t.className = "tile";
      t.textContent = EMOJIS[board[r][c]];
      t.style.left = (pad + c*step) + "px";
      t.style.top  = (pad + r*step) + "px";
      t.style.width = tile + "px"; t.style.height= tile + "px";
      t.style.fontSize = (tile*0.7) + "px";
      t.dataset.r = r; t.dataset.c = c;
      elBoard.appendChild(t);
    }
  }
}
function getTileEl(r,c){ return document.querySelector(`.tile[data-r='${r}'][data-c='${c}']`); }

// Swipe
let gesture = null;
function cellFromClient(x,y){
  const rect = elBoard.getBoundingClientRect();
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8;
  const pad = gap;
  const step = stepPx();
  const rr = Math.floor((y - rect.top  - pad) / step);
  const cc = Math.floor((x - rect.left - pad) / step);
  if (rr<0||cc<0||rr>=ROWS||cc>=COLS) return null;
  return {r: rr, c: cc};
}
elBoard.addEventListener('pointerdown', (e)=>{
  if (busy || gesture) return;
  const cell = cellFromClient(e.clientX, e.clientY); if (!cell) return;
  gesture = { id: e.pointerId, startX: e.clientX, startY: e.clientY, r: cell.r, c: cell.c };
  const t = getTileEl(cell.r, cell.c); if (t) t.classList.add('selected');
  elBoard.setPointerCapture(e.pointerId);
}, {passive:true});
elBoard.addEventListener('pointerup', async (e)=>{
  if (!gesture || e.pointerId !== gesture.id) return;
  const {r,c,startX,startY} = gesture; gesture = null;
  const t = getTileEl(r,c); if (t) t.classList.remove('selected');
  const dx = e.clientX - startX, dy = e.clientY - startY;
  const thr = 18; const absx = Math.abs(dx), absy = Math.abs(dy);
  if (absx < thr && absy < thr){
    if (toolMode !== 'none'){
      const cell = cellFromClient(e.clientX, e.clientY) || {r,c};
      if (toolMode==='rocket') { useRocket(cell.c); }
      else if (toolMode==='bomb') { useBomb(cell.r, cell.c); }
      else if (toolMode==='joker') { useJoker(); }
      else if (toolMode==='kitty') { useKitty(cell.r, cell.c); }
      setTool('none'); return;
    }
    return;
  }
  if (absx > absy){
    if (dx>0 && c<COLS-1) await attemptSwap({r,c},{r,c:c+1});
    else if (dx<0 && c>0) await attemptSwap({r,c},{r,c:c-1});
  } else {
    if (dy>0 && r<ROWS-1) await attemptSwap({r,c},{r:r+1,c});
    else if (dy<0 && r>0) await attemptSwap({r,c},{r:r-1,c});
  }
}, {passive:true});
elBoard.addEventListener('pointercancel', (e)=>{ if (gesture && e.pointerId===gesture.id) gesture=null; });

async function attemptSwap(a,b){
  if (busy) return; busy = true;
  try {
    await animateSwap(a,b);
    swap(a,b);
    const matched = findMatches();
    if (matched.size === 0){
      if (typeof sfxInvalid==='function') sfxInvalid();
      await animateSwap(b,a);
      swap(a,b);
    } else {
      const runLen = (typeof largestMatchLen==='function' ? largestMatchLen() : 3);
      const big = runLen >= 4;
      if (big && typeof sfxBig==='function') sfxBig();
      else if (typeof sfxValid==='function') sfxValid();
      await resolveMatches();
    }
  } finally { busy = false; }
}
function swap(a,b){ const t = board[a.r][a.c]; board[a.r][a.c] = board[b.r][b.c]; board[b.r][b.c] = t; }
function findMatches(){
  const clear = new Set();
  for (let r=0;r<ROWS;r++){
    let count=1;
    for (let c=1;c<=COLS;c++){
      const same = c<COLS && board[r][c]===board[r][c-1];
      if (same) count++; else { if (count>=3) for (let k=c-count;k<c;k++) clear.add(`${r},${k}`); count=1; }
    }
  }
  for (let c=0;c<COLS;c++){
    let count=1;
    for (let r=1;r<=ROWS;r++){
      const same = r<ROWS && board[r][c]===board[r-1][c];
      if (same) count++; else { if (count>=3) for (let k=r-count;k<r;k++) clear.add(`${k},${c}`); count=1; }
    }
  }
  return clear;
}
function findClusters(){
  const clusters = [];
  // horizontal
  for (let r=0;r<ROWS;r++){
    let count=1;
    for (let c=1;c<=COLS;c++){
      const same = c<COLS && board[r][c]===board[r][c-1];
      if (same) { count++; }
      else {
        if (count>=3){
          const cells = [];
          for (let k=c-count;k<c;k++) cells.push([r,k]);
          clusters.push({cells, length: count, dir:'h'});
        }
        count = 1;
      }
    }
  }
  // vertikal
  for (let c=0;c<COLS;c++){
    let count=1;
    for (let r=1;r<=ROWS;r++){
      const same = r<ROWS && board[r][c]===board[r-1][c];
      if (same) { count++; }
      else {
        if (count>=3){
          const cells = [];
          for (let k=r-count;k<r;k++) cells.push([k,c]);
          clusters.push({cells, length: count, dir:'v'});
        }
        count = 1;
      }
    }
  }
  return clusters;
}
function largestMatchLen(){
  let maxRun = 0;
  for (let r=0;r<ROWS;r++){
    let count=1;
    for (let c=1;c<=COLS;c++){
      const same = c<COLS && board[r][c]===board[r][c-1];
      if (same) { count++; } else { if (count>maxRun) maxRun=count; count=1; }
    }
  }
  for (let c=0;c<COLS;c++){
    let count=1;
    for (let r=1;r<=ROWS;r++){
      const same = r<ROWS && board[r][c]===board[r-1][c];
      if (same) { count++; } else { if (count>maxRun) maxRun=count; count=1; }
    }
  }
  return maxRun;
}

async function resolveMatches(){
  let totalCleared = 0; chain = 0;
  while (true){
    const toClear = findMatches();

    // Flash + Charges
    (function(){
      const clusters = findClusters();
      let triples=0, fours=0, fives=0;
      const flashRocket = [], flashBomb = [];
      for (const cl of clusters){
        if (cl.length >= 5){ fives++; flashBomb.push(...cl.cells); }
        else if (cl.length === 4){ fours++; flashRocket.push(...cl.cells); }
        else if (cl.length === 3){ triples++; }
      }
      flashRocket.forEach(([rr,cc])=>{ const el=getTileEl(rr,cc); if(el) el.classList.add('flash-rocket'); });
      flashBomb.forEach(([rr,cc])=>{ const el=getTileEl(rr,cc); if(el) el.classList.add('flash-bomb'); });
      setTimeout(()=>{
        flashRocket.forEach(([rr,cc])=>{ const el=getTileEl(rr,cc); if(el) el.classList.remove('flash-rocket'); });
        flashBomb.forEach(([rr,cc])=>{ const el=getTileEl(rr,cc); if(el) el.classList.remove('flash-bomb'); });
      }, 420);

      kittyProgress += triples;
      while (kittyProgress >= 15){ kittyProgress -= 15; unlockKitty(); }
      for (let i=0;i<fours;i++) unlockRocket();
      for (let i=0;i<fives;i++) unlockBomb();
    })();

    if (toClear.size===0) break;

    chain++;
    toClear.forEach(key=>{ const [r,c]=key.split(',').map(Number); const el=getTileEl(r,c); if (el) el.classList.add('match'); });
    await sleep(240);
    toClear.forEach(key=>{ const [r,c]=key.split(',').map(Number); board[r][c] = -1; });
    // nachfallen + auff√ºllen
    for (let c=0;c<COLS;c++){
      let write = ROWS-1;
      for (let r=ROWS-1;r>=0;r--){
        if (board[r][c]!==-1){ board[write][c]=board[r][c]; write--; }
      }
      for (let r=write;r>=0;r--) board[r][c] = randType();
    }
    draw(); await sleep(140);
    totalCleared += toClear.size;
  }
  if (totalCleared>0){
    const points = totalCleared * 10 * Math.max(1, chain*0.9);
    updateScore(points|0);
  }
}

async function animateSwap(a,b){
  const elA = getTileEl(a.r,a.c), elB = getTileEl(b.r,b.c); if (!elA || !elB) return;
  const step = stepPx(); const dx = (b.c-a.c)*step; const dy = (b.r-a.r)*step;
  elA.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
  elB.style.transform = 'translate(' + (-dx) + 'px,' + (-dy) + 'px)';
  await sleep(180);
  elA.style.transform = 'translate(0,0)'; elB.style.transform = 'translate(0,0)';
}
function updateScore(inc){ score += inc; elScore.textContent = score; if (score>best){ best=score; localStorage.setItem('kitty-best', best); elBest.textContent=best; } }

// Tools
function unlockRocket(){
  rocketCharges = (rocketCharges||0) + 1;
  if (!rocketUnlocked){
    rocketUnlocked = true;
    const btn = document.getElementById('btnRocket');
    if (btn){ btn.disabled = false; btn.classList.add('unlock-pop'); setTimeout(()=>btn.classList.remove('unlock-pop'), 500); }
  }
  refreshToolsUI();
}
function unlockBomb(){
  bombCharges = (bombCharges||0) + 1;
  if (!bombUnlocked){
    bombUnlocked = true;
    const btn = document.getElementById('btnBomb');
    if (btn){ btn.disabled = false; btn.classList.add('unlock-pop'); setTimeout(()=>btn.classList.remove('unlock-pop'), 500); }
  }
  refreshToolsUI();
}
function unlockKitty(){
  kittyCharges = (kittyCharges||0) + 1;
  if (!kittyUnlocked){
    kittyUnlocked = true;
    const btn = document.getElementById('btnKitty');
    if (btn){ btn.disabled = false; btn.classList.add('unlock-pop'); setTimeout(()=>btn.classList.remove('unlock-pop'), 500); }
  }
  refreshToolsUI();
}
async function useJoker(){
  if (busy || jokerUsed) return;
  busy = true;
  try{
    if (typeof sfxJoker==='function') sfxJoker();
    elBoard.classList.add('rewind');
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) board[r][c] = randType();
    draw(); await sleep(220); elBoard.classList.remove('rewind');
    jokerUsed = true;
    const btn = document.getElementById('btnJoker'); if (btn) btn.disabled = true; btn.setAttribute('aria-pressed','false');
    await resolveMatches();
  } finally { busy=false; }
}
async function useRocket(col){
  if (rocketCharges <= 0) { setTool('none'); return; }
  if (busy) return;
  if (col<0 || col>=COLS) { setTool('none'); return; }
  busy = true;
  try{
    if (typeof sfxRocket==='function') sfxRocket();
    for (let r=ROWS-1, delay=0; r>=0; r--, delay+=30){
      const el = getTileEl(r,col); if (el){ setTimeout(()=>{ el.classList.add('rocket-pop'); }, delay); }
    }
    await sleep(260 + ROWS*30);
    for (let r=0;r<ROWS;r++) board[r][col] = -1;
    for (let c=0;c<COLS;c++){
      let write = ROWS-1;
      for (let r=ROWS-1;r>=0;r--){
        if (board[r][c]!==-1){ board[write][c]=board[r][c]; write--; }
      }
      for (let r=write;r>=0;r--) board[r][c] = randType();
    }
    draw(); await sleep(120); await resolveMatches();
    rocketCharges = Math.max(0, rocketCharges-1); refreshToolsUI(); setTool('none');
  } finally { busy=false; }
}
async function useBomb(r,c){
  if (bombCharges <= 0) { setTool('none'); return; }
  if (busy) return; busy = true;
  try{
    if (typeof sfxBomb==='function') sfxBomb();
    const deltas = [[0,-1],[-1,-1],[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1]];
    const targets = [];
    for (const [dr,dc] of deltas){
      const rr = r+dr, cc = c+dc;
      if (rr>=0 && rr<ROWS && cc>=0 && cc<COLS){
        targets.push([rr,cc]);
        const el = getTileEl(rr,cc); if (el) el.classList.add('bomb-pop');
      }
    }
    await sleep(260);
    for (const [rr,cc] of targets) board[rr][cc] = -1;
    for (let c2=0;c2<COLS;c2++){
      let write = ROWS-1;
      for (let r2=ROWS-1;r2>=0;r2--){
        if (board[r2][c2]!==-1){ board[write][c2]=board[r2][c2]; write--; }
      }
      for (let r2=write;r2>=0;r2--) board[r2][c2] = randType();
    }
    draw(); await sleep(120); await resolveMatches();
    bombCharges = Math.max(0, bombCharges-1); refreshToolsUI(); setTool('none');
  } finally { busy=false; }
}
async function useKitty(r,c){
  if (kittyCharges <= 0) { setTool('none'); return; }
  if (r==null || c==null) { setTool('none'); return; }
  if (r<0||c<0||r>=ROWS||c>=COLS) { setTool('none'); return; }
  if (busy) return;
  busy = true;
  try{
    const target = board[r][c];
    if (target == null || target < 0){ busy=false; setTool('none'); return; }
    if (typeof sfxKitty==='function') sfxKitty();
    const victims = [];
    for (let rr=0; rr<ROWS; rr++) for (let cc=0; cc<COLS; cc++) if (board[rr][cc] === target) victims.push([rr,cc]);
    for (const [rr,cc] of victims){ const el = getTileEl(rr,cc); if (el) el.classList.add('kitty-pop'); }
    await sleep(260);
    for (const [rr,cc] of victims) board[rr][cc] = -1;
    updateScore(10 * victims.length);
    for (let c2=0;c2<COLS;c2++){ let write = ROWS-1; for (let r2=ROWS-1;r2>=0;r2--){ if (board[r2][c2]!==-1){ board[write][c2]=board[r2][c2]; write--; } } for (let r2=write;r2>=0;r2--) board[r2][c2] = randType(); }
    draw(); await sleep(120);
    await resolveMatches();
    kittyCharges = Math.max(0, kittyCharges-1); refreshToolsUI(); setTool('none');
  } finally { busy = false; }
}

// Starfield (Deko)
(function(){
  try{
    const cvs=document.getElementById('starfield'); if(!cvs) return;
    const ctx=cvs.getContext('2d'); let stars=[];
    function fit(){ cvs.width=innerWidth; cvs.height=innerHeight; stars = Array.from({length:Math.floor(innerWidth*innerHeight/2600)}, ()=>({x:Math.random()*innerWidth,y:Math.random()*innerHeight,r:Math.random()*1.5+.3,t:Math.random()*6})); }
    window.addEventListener('resize', fit); fit();
    (function loop(t){ ctx.clearRect(0,0,cvs.width,cvs.height); for(const s of stars){ const a=.5+.5*Math.sin(t*.001+s.t); ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,'+a+')'; ctx.fill(); s.x+=.02; s.y+=.01; if(s.x>innerWidth)s.x=0; if(s.y>innerHeight)s.y=0;} requestAnimationFrame(loop); })();
  }catch(e){}
})();

/* ====== Audio Engine: Tag ‚Üí Nacht (mobile-optimiert) ====== */
(function(){
  try{
    const AC = window.AudioContext || window.webkitAudioContext; if(!AC) return;
    const audio={
      ctx:null, master:null, sfx:null,
      music:null, dayBus:null, nightBus:null,
      dry:null, delay:null, fb:null, wet:null,
      started:false, muted:false, mode:"day",
      daySched:null, nightSched:null, crossTimer:null,
      visible:true
    };
    window.audio = audio;

    function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

    function ensure(){
      if(audio.started) return;
      audio.ctx = new AC();

      // Master & Busses
      audio.master = audio.ctx.createGain(); audio.master.gain.value = .8;
      audio.sfx    = audio.ctx.createGain();

      audio.music  = audio.ctx.createGain();
      audio.dayBus = audio.ctx.createGain();   audio.dayBus.gain.value = 0.9;
      audio.nightBus = audio.ctx.createGain(); audio.nightBus.gain.value = 0.0;
      audio.dayBus.connect(audio.music);
      audio.nightBus.connect(audio.music);

      // Leichter Delay (Ping-Pong-artig, low CPU)
      audio.dry   = audio.ctx.createGain(); audio.dry.gain.value = 0.85;
      audio.delay = audio.ctx.createDelay(1.0); audio.delay.delayTime.value = 0.28;
      audio.fb    = audio.ctx.createGain(); audio.fb.gain.value = 0.22;
      audio.wet   = audio.ctx.createGain(); audio.wet.gain.value = 0.18;

      audio.music.connect(audio.dry);
      audio.music.connect(audio.delay);
      audio.delay.connect(audio.fb); audio.fb.connect(audio.delay);
      audio.delay.connect(audio.wet);

      audio.dry.connect(audio.master);
      audio.wet.connect(audio.master);
      audio.sfx.connect(audio.master);
      audio.master.connect(audio.ctx.destination);

      startDayMusic();
      // Auto-Nachtmodus nach 2 Minuten
      audio.crossTimer = setTimeout(beginNightMode, 120000);

      audio.started = true;
    }
    window.ensureAudio = ensure;

    // ---------- Instrumente (leicht & sparsam) ----------
    function playTone({type="triangle", hz=440, t=0, dur=.5, gain=.2, cutoff=1500, target=audio.dayBus}){
      const o = audio.ctx.createOscillator();
      o.type = type; o.frequency.setValueAtTime(hz, t);
      const f = audio.ctx.createBiquadFilter(); f.type = "lowpass"; f.frequency.setValueAtTime(cutoff, t);
      const v = audio.ctx.createGain();
      v.gain.setValueAtTime(0.0001, t);
      v.gain.linearRampToValueAtTime(gain, t+0.02);
      v.gain.exponentialRampToValueAtTime(Math.max(0.0001,gain*0.35), t+Math.min(0.12,dur*0.4));
      v.gain.exponentialRampToValueAtTime(0.0001, t + Math.max(0.18, dur*0.9));
      o.connect(f); f.connect(v); v.connect(target);
      o.start(t); o.stop(t+dur+0.05);
    }
    function bass(hz, t, beat, target){ playTone({type:"sine", hz:hz*0.5, t, dur:beat*0.95, gain:.22, cutoff:700, target}); }
    function arp(hz, t, stepDur, target){ playTone({type:"triangle", hz, t, dur:stepDur*0.98, gain:.14, cutoff:1800, target}); }
    function padChord(hzList, t, beat, target){
      hzList.forEach((hz,i)=> playTone({type:"sawtooth", hz, t, dur:beat*3.6, gain:.055, cutoff:900 + i*120, target}));
    }
    function bell(hz, t, stepDur, target){
      // kurzer "Candy"-Bell
      playTone({type:"square", hz, t, dur:stepDur*0.8, gain:.10, cutoff:2400, target});
    }

    // ---------- Day Track ----------
    function startDayMusic(){
      const bpm = 96;
      const beat = 60/bpm;
      const step = beat/2;
      const lookahead = 25;       // ms
      const scheduleAhead = 0.25; // s

      const progression = [
        [60,64,67], // C
        [57,60,64], // Am
        [53,57,60], // F
        [55,59,62], // G
        [60,64,67], // C
        [52,55,59], // Em
        [53,57,60], // F
        [55,59,62], // G
      ];
      const arpPattern = [0,1,2,1,0,1,2,1];
      let nextTime = audio.ctx.currentTime + 0.1;
      let stepIndex = 0;

      function schedule(){
        if (!audio.visible) return;
        while (nextTime < audio.ctx.currentTime + scheduleAhead){
          const bar = Math.floor(stepIndex / 8);
          const stepInBar = stepIndex % 8;
          const chord = progression[bar % progression.length];
          const root = chord[0];
          const hzChord = chord.map(m=>midiToHz(m));

          if (stepInBar === 0){ padChord(hzChord.map(h=>h*0.5), nextTime, beat, audio.dayBus); }
          if (stepInBar % 2 === 0){
            const bassNote = midiToHz(root - 12 + (Math.random()<0.2? -12:0));
            bass(bassNote, nextTime, beat, audio.dayBus);
          }
          const deg = arpPattern[stepInBar % arpPattern.length];
          let noteMidi = chord[deg] + (Math.random()<0.35 ? 12 : 0);
          if (Math.random()<0.12) noteMidi += (Math.random()<0.5? -2:2);
          arp(midiToHz(noteMidi), nextTime, step, audio.dayBus);

          if (Math.random()<0.18 && stepInBar!==0){
            const sp = chord[(deg+1)%3] + 12 + (Math.random()<0.4?12:0);
            bell(midiToHz(sp), nextTime + step*0.5, step, audio.dayBus);
          }
          nextTime += step; stepIndex++;
        }
      }
      audio.daySched = setInterval(schedule, lookahead);
    }

    // ---------- Night Track (ruhig, langsamer, weiche Pads) ----------
    function startNightMusic(){
      if (audio.nightSched) return;
      const bpm = 72;
      const beat = 60/bpm;
      const step = beat/2;
      const lookahead = 30;        // ms (langsamer)
      const scheduleAhead = 0.35;  // s

      const progression = [
        [57,60,64], // Am
        [53,57,60], // F
        [60,64,67], // C
        [55,59,62], // G
      ];
      const arpPattern = [0,1,1,2,1,0,0,1]; // seltener Wechsel

      let nextTime = audio.ctx.currentTime + 0.1;
      let stepIndex = 0;

      function schedule(){
        if (!audio.visible) return;
        while (nextTime < audio.ctx.currentTime + scheduleAhead){
          const bar = Math.floor(stepIndex / 8);
          const stepInBar = stepIndex % 8;
          const chord = progression[bar % progression.length];
          const root = chord[0];
          const hzChord = chord.map(m=>midiToHz(m));

          // L√§ngere Pads, kein st√§ndiger Arp
          if (stepInBar === 0){ padChord(hzChord.map(h=>h*0.5), nextTime, beat*1.25, audio.nightBus); }
          if (stepInBar % 4 === 0){
            const b = midiToHz(root - 12);
            bass(b, nextTime, beat*1.1, audio.nightBus);
          }
          // Arp nur gelegentlich
          if (Math.random() < 0.45){
            const deg = arpPattern[stepInBar];
            const note = chord[deg] + (Math.random()<0.25?12:0);
            arp(midiToHz(note), nextTime, step*0.95, audio.nightBus);
          }
          // Dezenter Glitzer noch seltener
          if (Math.random() < 0.12 && stepInBar>0){
            const bellMidi = chord[(stepInBar%3)] + 12;
            bell(midiToHz(bellMidi), nextTime + step*0.5, step, audio.nightBus);
          }
          nextTime += step; stepIndex++;
        }
      }
      audio.nightSched = setInterval(schedule, lookahead);
    }

    // Crossfade zu Nacht
    function beginNightMode(){
      if (!audio.started) return;
      startNightMusic();
      audio.mode = "night";
      // sanfte √úberblendung
      const now = audio.ctx.currentTime;
      audio.dayBus.gain.cancelScheduledValues(now);
      audio.nightBus.gain.cancelScheduledValues(now);
      audio.dayBus.gain.setValueAtTime(audio.dayBus.gain.value, now);
      audio.nightBus.gain.setValueAtTime(audio.nightBus.gain.value, now);
      audio.dayBus.gain.linearRampToValueAtTime(0.0, now + 6.0);
      audio.nightBus.gain.linearRampToValueAtTime(0.35, now + 6.0);
    }

    // Sichtbarkeit: pausieren f√ºr Akku/CPU
    document.addEventListener('visibilitychange', ()=>{
      audio.visible = !document.hidden;
    });

    // ---- SFX (wie gehabt) ----
    function now(){ return audio.ctx.currentTime; }
    function noise(t,len=.12,g=.7){
      const buf=audio.ctx.createBuffer(1, Math.floor(audio.ctx.sampleRate*len), audio.ctx.sampleRate);
      const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length);
      const s=audio.ctx.createBufferSource(); s.buffer=buf; const v=audio.ctx.createGain(); v.gain.value=g; s.connect(v); v.connect(audio.sfx); s.start(t);
    }
    window.sfxInvalid=function(){ if(!audio.started||audio.muted) return; const t=now(); const o=audio.ctx.createOscillator(); const v=audio.ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(220,t); o.frequency.exponentialRampToValueAtTime(80,t+.24); v.gain.setValueAtTime(.0001,t); v.gain.exponentialRampToValueAtTime(1.0,t+.012); v.gain.exponentialRampToValueAtTime(.0001,t+.32); o.connect(v); v.connect(audio.sfx); o.start(t); o.stop(t+.34); };
    window.sfxValid=function(){ if(!audio.started||audio.muted) return; const t=now(); [880,988,1175].forEach((f,i)=>{ const o=audio.ctx.createOscillator(); const v=audio.ctx.createGain(); o.type='triangle'; o.frequency.value=f; v.gain.setValueAtTime(.0001,t+i*.05); v.gain.linearRampToValueAtTime(.45-i*.1,t+i*.05+.02); v.gain.exponentialRampToValueAtTime(.0001,t+i*.05+.3); o.connect(v); v.connect(audio.sfx); o.start(t+i*.05); o.stop(t+i*.05+.32); }); };
    window.sfxBig=function(){ if(!audio.started||audio.muted) return; const t=now(); [988,1175,1319,1568].forEach((f,i)=>{ const o=audio.ctx.createOscillator(); const v=audio.ctx.createGain(); o.type='sine'; o.frequency.value=f; v.gain.setValueAtTime(.0001,t+i*.05); v.gain.linearRampToValueAtTime(.55-i*.08,t+i*.05+.02); v.gain.exponentialRampToValueAtTime(.0001,t+i*.05+.36); o.connect(v); v.connect(audio.sfx); o.start(t+i*.05); o.stop(t+i*.05+.4); }); };
    window.sfxRocket=function(){ if(!audio.started||audio.muted) return; const t=now(); const o=audio.ctx.createOscillator(); const v=audio.ctx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(220,t); o.frequency.exponentialRampToValueAtTime(880,t+.3); v.gain.setValueAtTime(.0001,t); v.gain.linearRampToValueAtTime(.6,t+.05); v.gain.exponentialRampToValueAtTime(.0001,t+.5); o.connect(v); v.connect(audio.sfx); o.start(t); o.stop(t+.5); };
    window.sfxBomb=function(){ if(!audio.started||audio.muted) return; const t=now(); noise(t,.12,.8); const o=audio.ctx.createOscillator(); const v=audio.ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(660,t); o.frequency.exponentialRampToValueAtTime(330,t+.12); v.gain.setValueAtTime(.0001,t); v.gain.linearRampToValueAtTime(.35,t+.02); v.gain.exponentialRampToValueAtTime(.0001,t+.2); o.connect(v); v.connect(audio.sfx); o.start(t); o.stop(t+.22); };
    window.sfxJoker=function(){ if(!audio.started||audio.muted) return; const t=now(); const o=audio.ctx.createOscillator(); const v=audio.ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(880,t); o.frequency.exponentialRampToValueAtTime(330,t+.18); v.gain.setValueAtTime(.0001,t); v.gain.linearRampToValueAtTime(.5,t+.02); v.gain.exponentialRampToValueAtTime(.0001,t+.36); o.connect(v); v.connect(audio.sfx); o.start(t); o.stop(t+.38); };

    // Sound-Button
    const btn=document.getElementById('toggleSound');
    if(btn) btn.addEventListener('click', ()=>{
      if(!audio.started && !audio.muted) ensure();
      audio.muted = !audio.muted;
      const v = audio.muted?0.0:0.8;
      if(audio.master) audio.master.gain.value=v;
      btn.setAttribute('aria-pressed', String(!audio.muted));
      btn.textContent = audio.muted? 'üîà Sound aus' : 'üîä Sound an';
    });

    // Autostart der Engine beim ersten Interaktions-Event (Mobile-kompatibel)
    ['pointerdown','keydown','touchstart'].forEach(ev=>
      window.addEventListener(ev, ()=>{ if(!audio.started && !(audio.muted)) ensure(); }, {once:true, passive:true})
    );
  }catch(e){}
})();

// Start
init();
window.addEventListener('resize', draw);
document.getElementById('new')?.addEventListener('click', ()=>{ if (typeof ensureAudio==='function') ensureAudio(); init(); });
</script>
</body>
</html>
